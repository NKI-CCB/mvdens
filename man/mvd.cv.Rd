% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cross_validation.r
\name{mvd.cv}
\alias{mvd.cv}
\title{Estimate the approximation accuracy of a multivariate density using cross validation}
\usage{
mvd.cv(x, p, log, type, cvtype, nfolds = 10, mcsize = nrow(x)/10,
  parallel = F, verbose = F, fit.params = list())
}
\arguments{
\item{x}{Matrix or vector of samples. For matrices, rows are samples and columns are variables.}

\item{p}{Vector of posterior probability densities of the samples.}

\item{log}{Boolean which specifies whether p is in log space.}

\item{type}{String describing the type of the density approximation to use, can be: kde, kde.transformed, gmm, gmm.transformed, gmm.truncated, gp, vc.ecdf, vc.ecdf.pareto, vc.parametric, vc.mixture}

\item{cvtype}{String describing the type of cross validation to use, can be either kfoldcv, mccv or fixed}

\item{nfolds}{The number of cross validation folds (i.e. K when using K-fold cross validation, or the number of iterations in Monte Carlo cross validation).}

\item{mcsize}{When using Monte Carlo cross validation, this specifies the size of the test set.}

\item{parallel}{When true, and when parallel workers have been registered, run the cross validation in parallel using foreach. The user should start the parallel workers (see examples).}

\item{verbose}{Display the progress (when parallel=F).}

\item{fit.params}{A named list with parameters to be relayed to the density fitting functions.}
}
\description{
Perform cross validation to estimate the accuracy of the density approximations. This requires the known probability densities at the sample points, though these probability densities do not have to be normalized. If they are not normalized, then only the correlation is a meaningful performance measure. If they are normalized, the RMSE is also informative.
Either K-fold cross validation or Monte Carlo cross validation can be performed.
}
\examples{
mu <- c(0,0)
sigma <- rbind(c(1,0.5),c(0.5,1))
x <- mvtnorm::rmvnorm(40, mu, sigma)
p <- mvtnorm::dmvnorm(x, mu, sigma)
res <- mvd.cv(x, p, 'gmm', log=FALSE, cvtype='kfoldcv', nfolds=4, verbose=TRUE)

#library(doParallel)
#cl <- parallel::makeCluster(6)
#doParallel::registerDoParallel(cl)
#parallel::clusterEvalQ(cl, library(mvdens))
#res <- mvd.cv(x, p, 'gmm', log=FALSE, cvtype='kfoldcv', nfolds=4, parallel=TRUE)
}
